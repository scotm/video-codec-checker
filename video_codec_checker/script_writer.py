"""Helpers to generate conversion shell scripts with optional cleanup.

This module centralizes script generation so main remains lean.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from shlex import quote as sh_quote
from shutil import which
from typing import IO


@dataclass
class TrashConfig:
    use_trash: bool
    bin: str = ""
    arg: str = ""


def resolve_trash_config(trash_original: bool) -> TrashConfig:
    """Resolve trash configuration based on installed utilities.

    - If trash_original is False: return config with use_trash=False
    - If True: prefer `trash`, then `gio trash`, then `trash-put`.
      If none found, raise RuntimeError.
    """
    if not trash_original:
        return TrashConfig(use_trash=False)

    if which("trash"):
        return TrashConfig(use_trash=True, bin="trash", arg="")
    if which("gio"):
        return TrashConfig(use_trash=True, bin="gio", arg="trash")
    if which("trash-put"):
        return TrashConfig(use_trash=True, bin="trash-put", arg="")
    raise RuntimeError(
        "--trash-original requested, but no trash utilities found. Install one of: "
        "'trash', 'gio' (with 'trash'), or 'trash-put'; or use --delete-original."
    )


class ScriptWriter:
    """Writes a shell script with conversion commands and optional cleanup."""

    def __init__(
        self,
        path: Path | str,
        delete_original: bool = False,
        trash_config: TrashConfig | None = None,
    ) -> None:
        self.path = Path(path)
        self.delete_original = delete_original
        self.trash_config = trash_config or TrashConfig(use_trash=False)
        self._fh: IO[str] | None = None

    def open(self) -> None:
        ts = datetime.now().isoformat()
        fh = self.path.open("w", encoding="utf-8")
        self._fh = fh
        fh.write("#!/usr/bin/env bash\n")
        fh.write("set -euo pipefail\n")
        fh.write(f"# Generated by video-codec-checker on {ts}\n\n")

        if self.delete_original or self.trash_config.use_trash:
            fh.write(
                "cleanup_source() {\n"
                '  src="$1"\n'
                '  if [ "$USE_TRASH" = "1" ]; then\n'
                '    if [ -n "$TRASH_ARG" ]; then\n'
                '      "$TRASH_BIN" "$TRASH_ARG" "$src" || true\n'
                "    else\n"
                '      "$TRASH_BIN" "$src" || true\n'
                "    fi\n"
                "  else\n"
                '    rm -f -- "$src"\n'
                "  fi\n"
                "}\n"
            )
            fh.write(
                "run_and_cleanup() {\n"
                "  # args: <cmd> <src> <dst>\n"
                "  set +e\n"
                '  eval "$1"\n'
                "  rc=$?\n"
                "  set -e\n"
                '  if [ $rc -eq 0 ] && [ -f "$3" ]; then\n'
                '    echo "[CLEANUP] Removing source: $2"\n'
                '    cleanup_source "$2"\n'
                "  fi\n"
                "  return $rc\n"
                "}\n\n"
            )

            if self.trash_config.use_trash:
                fh.write("export USE_TRASH=1\n")
                fh.write(f"export TRASH_BIN={self.trash_config.bin}\n")
                fh.write(f"export TRASH_ARG={self.trash_config.arg}\n\n")
            else:
                fh.write("export USE_TRASH=0\n\n")

    def write_command(self, ffmpeg_cmd: str, src: Path, dst: Path) -> None:
        fh = self._require_open()
        line = (
            f"run_and_cleanup {sh_quote(ffmpeg_cmd)} {sh_quote(str(src))} "
            f"{sh_quote(str(dst))}\n"
        )
        fh.write(line)

    def write_command_no_cleanup(self, ffmpeg_cmd: str) -> None:
        fh = self._require_open()
        fh.write(ffmpeg_cmd + "\n")

    def close(self) -> None:
        fh = self._require_open()
        fh.flush()
        fh.close()
        self._fh = None

    # Internal
    def _require_open(self) -> IO[str]:
        if self._fh is None:
            raise RuntimeError("ScriptWriter is not open")
        return self._fh
